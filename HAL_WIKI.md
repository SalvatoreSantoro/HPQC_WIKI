# UninaSoC Software Build System

My work focused on integrating "risc-v_hands_on" examples on UninaSoC,
and doing a refactoring of the structure of the software-related part of the platform
that led to the design of a first version of the HAL.
In order to run custom code and experiment with low level mechanisms
like interrupts and peripherals interfacing, every application need to follow
the convention exposed in the related documentation page:
https://github.com/MaistoV/UninaSoC/blob/main/sw/SoC/README.md

Every example code for the platform need to be located in the
directory "sw/SoC/examples" in order to be compiled with the
software compilation flow of the system (make sw).

// Aggiungi immagine cartella examples

# UninaSoC for students: a new backend for risc-v_hands_on

## Integration

Respecting the build requirements mentioned above I integrated the examples
that were previously present in the repository "risc-v_hands_on" to run on the platform.
The goals were to integrate on UninaSoC both the "full assembly" and "mixed C/assembly" examples 
originally intended to run respectively on "RARS" and "spike".

// Aggiungi figura integrazione così come scritto in email

To run the examples in a bare metal context the code had to be adapted to use "TinyIO" library
(already present in the build system of UninaSoC) to print directly to screen using
an UART peripheral and a terminal emulator (PuTTY).

// Screen che ritrae le piccole porzioni di codice cambiate magari

## Installation and running with GDB

Setting up the project and running the code is completely guided in the
README.md file (in risc-v_hands_on/UninaSoC)
https://github.com/SalvatoreSantoro/risc-v_hands_on/blob/main/UninaSoC/README.md
that lists all the steps to reproduce using the Makefile specifically created for 
this eventuality.

After configuring everything needed, it's possible to run the examples using
GDB and a terminal emulator.

The source code of the TinyIO library, is recompiled from source (when running make sw)
on the host machine, in order to allow GDB to find the location of TinyIO's source files
and make it possible to "step" into the librarie's functions implementations.

// Screen esempio GDB + Screen print a video UART + screen step dentro funzione


# State of UninaSoC before refactoring

Before the refactoring UninaSoC didn't have an HAL and every example needed
to write initialization code from the ground up, in particular the "interrupts"
example specified functions to initialize every peripheral of the SoC, locally
in the example folder.
The code in this example was used as the foundation for building the HAL

// Screen della struttura dei file esempio interrupt com'era prima
// Screen del codice com'era prima

# Designing an HAL for UninaSoC

## Use cases

The use cases taken into account were:

1 - The HAL needs to be minimal, well-commented, and easily extensible to support educational use and experimentation with RISC-V interrupt handling.  

2 - The HAL needs to support modular compilation to minimize build time and binary size, using configuration files to include only required components.  

3 - The HAL needs to expose generic APIs that allow for future extension, including support for additional instances of peripherals (e.g., GPIOs, timers) and changes in hardware configuration.

// Snippet codice header + file generato

## Design Principles

### Unified Header Interface (uninasoc.h)
The HAL exposes a single header file, uninasoc.h, to provide a clean interface to developers internally integrating TinyIO library for printf functionality.

### Build-Time Configuration via uninasoc_config.h
The build process is controlled through a configuration header, "uninasoc_config.h", generated with the config script
"create_uninasoc_conf_header.py" which dictates which components are included during compilation.

### Peripheral Base Addresses from Linker-Generated Symbols
Rather than hardcoding peripheral base addresses, the HAL relies on symbols generated by the linker script (already present in the software build system of UninaSoC) to determine these addresses at compile time. This design makes the HAL highly adaptable to changes in the memory map. If the hardware configuration evolves (e.g., peripheral relocation), the HAL can automatically adjust without requiring source code changes, as long as the linker script is updated accordingly.

### Robust Peripheral Configuration and Error Handling
To facilitate debugging and development, the HAL includes clear and consistent error handling mechanisms during peripheral configuration.

### Redefinition of interrupt handlers
The HAL exposes the symbol "__irq_handler__" to the user in order to define custom interrupt handlers.
The user also need follow the naming convention "_ext_handler", "_tim_handler", "_sof_handler" because
the HAL redefines "weak" default implementation of the handler substituting them with the user custom handlers.

## HAL Architecture

// Inserire schema

## Example of use

Breve esempio di utilizzo dell'HAL e della gestione delle interruzioni attraverso
spiegazione dell'esempio delle interrupts  

## Future Developments

In generale si può parlare delle parti della HAL da riadattare o estendere
nel momento in cui si aggiungono nuove periferiche o si rende il PLIC configurabile
dinamicamente  



